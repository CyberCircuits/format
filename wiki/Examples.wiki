#summary Further examples of the format library

= Introduction =

The ReadMe page describes in detail the functionality that the `format` library provides.  This page provides illustrations of the additional features provided by `format` that extend the base C99-compatible functionality.


= Binary Conversion = 

The `b` conversion specification formats the unsigned integer argument into a binary base-2 number.  For example

{{{
n = format( cons, arg, "GPIO = %8.8b", 37 );
}}}

would send to the `cons` function the characters representing the output

{{{
GPIO = 00100101
}}}

= Continuation Conversion Specifier =

A recent addition to the `format` library is the continuation conversion specification.  Notionally it is written `%"`, in practice you place a `%` as the last character in a format string and `format` will continue parsing the format specification from the string pointed to by the next argument.

What does this mean in practice?  Here is an illustration of the problem this solves: to print out the contents of three elements of a structure:

{{{
struct {
   unsigned int acc;   /* Accumulator */
   unsigned int x;     /* X-register  */
   unsigned int y;     /* Y-register  */

   /* other stuff ... */

} cpu;

/* ... */

format( cons, arg, "A = %#!8.8X, X = %#!8.8X, Y = %#!8.8X", cpu.acc, cpu.x, cpu.y );
}}}

where `cons` and `arg` are placeholders for the corresponding arguments to `format`.

I think it looks ugly - there is no easy visual connection between the conversion specifiers and their corresponding arguments.  The situation only gets worse as fields are added, changed or removed - it is very easy to lose track of which conversion specifier relates to which argument!

With continuation this takes on a more natural look, allowing format specifications and arguments to be interspersed, much like in languages like Java and C++:

{{{
format( cons, arg, "A = %#!8.8X, %", cpu.acc, 
                   "X = %#!8.8X, %", cpu.x, 
                   "Y = %#!8.8X",    cpu.y );
}}}

= Caret Flag =

The new `^` flag centres the result of an `%s` conversion within the field if the field is wider than the argument string.

For example, printing `hello` in a delimited field 8 characters wide

{{{
format( cons, arg, "[%^8s]", "hello");
}}}

produces the output

{{{
[ hello  ]
}}}

How is this done?  During formating the `format` function calculates how many space padding characters are required to satisfy the given field width.  The default is to put the space padding on the left, resulting in right-justified text.  The `-` flag puts the space padding on the right, giving left-justified text.  The new `^` flag splits any space padding equally between left and right, centering the text.

Note that if the number of space padding characters is odd (such as in the above example) the odd space padding character is placed to the right of the text.  In the above example you can see that of the three space padding characters there is one to the left of the `hello`, and two to the right.

_One future option I may consider is to use the `-` flag in combination with the `^` flag to specify whether any odd space padding character is put on the left or the right.  Comments welcome._